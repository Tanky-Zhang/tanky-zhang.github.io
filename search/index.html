<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  <link rel="dns-prefetch" href="http://yoursite.com">
  
  <title>search | Tanky</title>
  <meta name="author" content="TankyZhang">
  
  <meta name="description" content="软件开发的小学生">
  
  
  <meta name="viewport" content="width=device-width,minimum-scale=1,initial-scale=1">

  <meta property="og:title" content="search"/>
  <meta property="og:site_name" content="Tanky"/>

  
    <meta property="og:image" content=""/>
  

  <link rel="alternate" href="/atom.xml" title="Tanky" type="application/atom+xml">

  <link rel="preload" as="style" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">

  <link rel="icon" class="js-site-favicon" type="image/svg+xml" href="https://github.githubassets.com/favicons/favicon.svg">
  <link href="https://unpkg.com" rel="dns-prefetch" />
  <link href="https://busuanzi.ibruce.info" rel="dns-prefetch" />
  <link href="https://cdn1.lncld.net" rel="dns-prefetch" />
  
<meta name="generator" content="Hexo 4.2.1"></head>

<body>
  <div class="container">
    <div class="left-col" style="background-image:url('https://tva1.sinaimg.cn/large/007S8ZIlgy1ggdmi6yapmj30dw0zk0wm.jpg')">
      <div class="intrude-less">
        <header id="header" class="inner">
          <a href="/">
            <div class="profilepic"><img src='https://tva1.sinaimg.cn/large/007S8ZIlgy1ggdmr1k3k0j305k05k74j.jpg'></div>
          </a>
          <div class="author-name"><a href="/">TankyZhang</a></div>
          <p class="aboutme">软件开发的小学生</p>
          <nav id="main-nav">
            <ul class="main">
              
              <li>
                
                  <a href="/archives">归档</a>
                
              </li>
              
              <li>
                
                  <a href="/categories">专题</a>
                
              </li>
              
              <li>
                
                  <a href="/friendlinks">友链</a>
                
              </li>
              
              <li>
                
                  <a href="/life">关于</a>
                
              </li>
              
              <li>
                
                  <a href="/search">搜索</a>
                
              </li>
              
            </ul>
          </nav>
          <nav id="sub-nav">
            <div class="social">
              
              <a class="twitter" href="https://twitter.com/" target="_blank" rel="noopener" title="Twitter">Twitter</a>
              
              
              
              <a class="github" href="https://github.com/" target="_blank" rel="noopener" title="Github">Github</a>
              
              
              <a class="yuque" href="https://yuque.com/" target="_blank" rel="noopener" title="语雀">语雀</a>
              

              
              <a class="rss" href="/atom.xml" title="RSS">RSS</a>
              
            </div>
          </nav>
        </header>
      </div>
    </div>
    <div class="mid-col">
      <div class="mid-col-container">
        <div id="content" class="inner">
          <article>
  <h1 class="title">search </h1>
  <div class="entry-content wrapper">
    <div id="search">
      <input type="text" placeholder="请输入关键字" id="Jinput">
    </div>
    <div class="info">
      本次搜索结果共<span id="Jcount">0</span>条
    </div>
    <div id="JresList"></div>

  


    <script>
      let searchData = [{"title":"源码分析","content":"jdk8中的HashMap源码解析与理解###一、预备知识\n关于hash：\n​    有个非常关键的特点，不定长度的输入固定长度的输出，将一个对象经过一定的hash算法映射成相同长度的hash值。\nhash冲突的避免：\n​    hash是无法完全避免的，只能通过各种方法手段尽量的减少hash冲突。\n关于hash碰撞的解决方案：\n\n开放地址法：假设一个数组有四个长度此时存放了[8,null,10,11,null]两个为null的位置代表没有数据，此时如果有个15来了，15mod 4=3那么这个15应该放在下标为3的位置上，但是3号位置有了数据，所以我们需要用（15+1）mod 4=4此时就放在了4位置，此时恰好没有数据，如果4位置有数据那么我们应该继续向下探测，即（15+1+1）mod 4得到对应的索引位置，直到找到可以放置的位置。\n\n再hash法：再哈希法又叫双哈希法，有多个不同的Hash函数，当发生冲突时，使用第二个，第三个，….，等哈希函数计算地址，直到无冲突。虽然不易发生聚集，但是增加了计算时间。\n链地址法：这个就是利用链表来实现，当发生hash冲突的时候我们将冲突的数据继续放在该位置，只不过要形成链表连接在这个位置的元素的后边。我们的hashmap就是利用这种方式来实现的hash冲突的解决。\n建立公共溢出区：将哈希表分为基本表和溢出表两部分，凡是和基本表发生冲突的元素，一律填入溢出表\n\n\n\n二、jdk8相对jdk7对于hashmap有哪些改进\njdk8采用了数组+链表+红黑树的数据结构进行数据的存储，而jdk7中采用了数组+链表的处理方式\n\njdk8中将数据插入链表的时候采用的是尾插法，而jdk7采用的是头插法。\njdk8中新增了一些新的特性，比如hashmap的foreach以及merge和replace方法\njdk8中在扩容数据迁移的时候是采用的高低位链的形式进行，而jdk7则是采用的头尾倒置的方式进行迁移。\n\n\n\n三、源码讲解理解jdk8中的hashmap源码中几个重要的参数：\n​    1. 加载因子：在hashmap中这个值默认是0.75。\n 2. map容量：map的容量并不一定等于实际创建时写入的map的容量，因为hashmap的容量一定是2的n次方，所以当我们申请一个大小为13的map的时候在实际创建的时候会申请一个大小为16的map，也就是说找到第一个大于或者等于申请大小的2的n次方的数据。**但是尤其重要的是这个容量是没有参数的，他一开始是存储在扩容阈值的那个参数中的**\n 3. 扩容阈值：加载因子*map的容量，假如map的容量为16加载因子为0.75那么扩容的阈值就是 $16\\ast0.75 =12$ ，也就是说当map中存放的元素如果大于了12那么就需要进行扩容。\n 4. 树化的阈值：在jdk8中当链表的长度大于了8以后会转为红黑树，这个8就是转为红黑树的阈值。\nhashmap中的key的hashcode是直接利用hashcode方法生成的吗？\n​    这个地方不是直接用原生的hashcode方法生成的，而是随原生的hashcode方法进行搞16位异或低16位的扰动，举个例子，假设存放key=“nihao”，如图：\n\n我们按照源码中的计算过程如下图：\n\n通过这样得二次位扰动加工处理我们尽可能得避免了hash碰撞得发生，进一步降低hash冲突的几率。\n​    我们可以通过另外一个例子分析一下是如何降低得，假设我们得数组长度是16那么我们在进行取模运算得时候则是通过hashcode&amp;(16-1)这样得运算得到得索引值，如果我们得key为“abcabcabcabcabc”，我们得到如下:\n\n\n\n1954974080（HashCode）\n111 0100 1000 0110 1000 1001 1000 0000\n\n\n\n2^4-1=15（length-1）\n000 0000 0000 0000 0000 0000 0000 1111\n\n\n&amp;运算\n000 0000 0000 0000 0000 0000 0000 0000\n\n\n而加上高16位异或低16位的“扰动函数”后，结果如下：\n\n\n\n原HashCode\n1954974080\n111 0100 1000 0110 1000 1001 1000 0000\n\n\n\n(&gt;&gt;&gt;16)无符号右移16位\n29830\n000 0000 0000 0000 0111 0100 1000 0110\n\n\n^（异或）运算\n1955003654\n111 0100 1000 0110 1111 1101 0000 0110\n\n\n2^4-1=15（length-1）\n15\n000 0000 0000 0000 0000 0000 0000 1111\n\n\n&amp;（与）运算\n6\n000 0000 0000 0000 0000 0000 0000 0110\n\n\n通过上边的例子我们可以得到，如果未进行扰动那么只要hashcode后四位为0那么无论前边28位如何变化得到的结果只会位0，但是进行扰动以后情况有所不同了，显然末尾变成了0110减少了碰撞几率。\nhashMap中数组的创建和初始化是一开始进行的吗？\n​    hashmap中的数组不是new的时候创建的，而是在第一次put的时候做的初始化使用懒加载的方式，节省了空间。如图：\n\n第一次会走如图的红框部分，进去这个分支以后会执行resize()方法，在resize中会对数组进行初始化。\n链表转为红黑树需要什么条件：\n​    链表转为红黑树主要要满足两个条件，一个是链表的长度大于8，另外一个是数组的长度大于64这个我们可以看下源码中的表现：\n\n在上图的程序中binCount表示了链表的长度，我们可以看到当bitcount&gt;=7的时候会执行treeifyBin()这个方法，既然是7为什么我们说大于8呢，这是因为bitCount等于7的时候我们其实已经循环了8次因为数组从0开始的，并且我们的p.next = newNode(hash, key, value, null);这段代码先执行也就是说先挂了一个node上去然后去判断的，所以此时除了根节点以外的长度是8而我们加上根节点，长度就变为了9，所以当大于8才会转为执行treeifyBin()这个方法，数组长度大于64又是从哪里体现呢，这个就在treeifyBin()方法中了，如图：\n\n此时我们可以看出当数组的长度小于64的时候会执行resize()操作进行二倍扩容。\n为什么转为红黑树的链表长度要大于8？\n​    因为这是根据一个理论基础叫泊松分布，泊松分布用于描述单位时间（或空间）内随机事件发生的次数。我们可以看到jdk源码中有这么一段注释\n\n1234567891011121314151617181920212223Because TreeNodes are about twice the size of regular nodes, weuse them only when bins contain enough nodes to warrant use(see TREEIFY_THRESHOLD). And when they become too small (due toremoval or resizing) they are converted back to plain bins.  Inusages with well-distributed user hashCodes, tree bins arerarely used.  Ideally, under random hashCodes, the frequency ofnodes in bins follows a Poisson distribution(http://en.wikipedia.org/wiki/Poisson_distribution) with aparameter of about 0.5 on average for the default resizingthreshold of 0.75, although with a large variance because ofresizing granularity. Ignoring variance, the expectedoccurrences of list size k are (exp(-0.5) * pow(0.5, k) /factorial(k)). The first values are:0:    0.606530661:    0.303265332:    0.075816333:    0.012636064:    0.001579525:    0.000157956:    0.000013167:    0.000000948:    0.00000006more: less than 1 in ten million\n\n通过上面的讲述我们发现其实链表在加载因子位0.75的情况发生树化的概率仅为0.00000006这个概率是极为低下的，也就是说在大多数的情况下我们的链表都不会转为红黑树。\n​    通常如果 hash 算法正常的话，那么链表的长度也不会很长，那么红黑树也不会带来明显的查询时间上的优势，反而会增加空间负担。所以通常情况下，并没有必要转为红黑树，所以就选择了概率非常小，小于千万分之一概率，也就是长度为 8 的概率，把长度 8 作为转化的默认阈值。\n​    所以如果平时开发中发现 HashMap 或是 ConcurrentHashMap 内部出现了红黑树的结构，这个时候往往就说明我们的哈希算法出了问题，需要留意是不是我们实现了效果不好的 hashCode 方法，并对此进行改进，以便减少冲突。\n为什么要采用链表转为红黑树的方式进行存储？\n​    为了提高查询的性能，正常情况下如果我们要查询的数据在链表的最后边那么我们需要从前向后的依次进行遍历，直到找到对应元素，这样的话我们的时间复杂度便是o(n),但是我们如果采用了红黑树这种结果的话，他是一种近似平衡二叉树，也就是左节点要比根节点小，右子节点比根节点大，所以此时的查找的时间复杂度位O(logn)。\n分析hashmap的put操作流程\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) {    Node&lt;K,V&gt;[] tab;    Node&lt;K,V&gt; p;    int n, i;    //第一次put的时候table为null    if ((tab = table) == null || (n = tab.length) == 0)        n = (tab = resize()).length;    //这个if分支代表当前的这个索引位置的元素为null 其实可以直接放入。    if ((p = tab[i = (n - 1) &amp; hash]) == null)        tab[i] = newNode(hash, key, value, null);    //如果不为null则需要使用头插法放在链表中    else {        Node&lt;K,V&gt; e; K k;        //第一个分支意味着新增的key原先就存在，所以直接替换        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))            e = p;        //这个分支意味着此时已经是一个红黑树的节点  也就是说链表长度已经大于了8        else if (p instanceof TreeNode)            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        //最后分支意味着普通情况的放入        else {            for (int binCount = 0; ; ++binCount) {                //如果当前的索引位置的节点的下一个节点为null证明可以直接放入到下一个节点                if ((e = p.next) == null) {                    p.next = newNode(hash, key, value, null);                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                        //判断转化为红黑树                        treeifyBin(tab, hash);                    break;                }                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                    break;                p = e;            }        }        if (e != null) {            // existing mapping for key            V oldValue = e.value;            if (!onlyIfAbsent || oldValue == null)                e.value = value;            afterNodeAccess(e);            return oldValue;        }    }    ++modCount;    //这里就是判断是否需要扩容   看的是size是否大于扩容的容量    if (++size &gt; threshold)        resize();    afterNodeInsertion(evict);    return null;}\n\n我们通过看源码不难看出put操作首先判断数组是不是null如果是null那么就进行初始化，初始化结束其实就分了四种情况，第一种就是需要放置的索引位置为null可以直接放置数据，第二种情况就是新增的key原先就存在需要直接替换，第三种情况就是他已经树化是一个红黑树，第四种情况就是正常的put操作，进行头插尾插法插入。\n\n注意：jdk1.7的时候是头插法，jdk1.8以后是尾插法插入。\n\n​    第一种直接放入元素即可，第二种情况就是判断hash值相同且key值相等，那么就是需要直接替换了，第四种情况就是在我们put的时候我们需要关注是否需要树化，即转为红黑树，我们在上边已经分析过转为红黑树的时机了，在遍历链表的时候同时也判断了是否需要替换相同的key。等到插入完成以后我们来判断是否达到了扩容的标准，即size是否大于threshold这个seize是个全局变量是实际放入到map中的数据量。\nhashmap的扩容（resize）解析\n​    当达到扩容阈值的时候会进行扩容操作，也就是执行resize()方法，代码如下：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687final Node&lt;K,V&gt;[] resize() {    Node&lt;K,V&gt;[] oldTab = table;    //旧的数组的长度  第一次put为0    int oldCap = (oldTab == null) ? 0 : oldTab.length;    //阈值    int oldThr = threshold;    //newThr代表了新的扩容阈值    int newCap, newThr = 0;        if (oldCap &gt; 0) {        if (oldCap &gt;= MAXIMUM_CAPACITY) {            threshold = Integer.MAX_VALUE;            return oldTab;        }        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)            //oldThr*2  这就是真正扩容的大小每次扩容两倍            newThr = oldThr &lt;&lt; 1; // double threshold    }    else if (oldThr &gt; 0)        //如果第一次执行会走入这个方法        newCap = oldThr;    else {        // zero initial threshold signifies using defaults        newCap = DEFAULT_INITIAL_CAPACITY;        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    }    if (newThr == 0) {        //第一次执行会走入这个分支  这里就是加载因子*数组的实际大小        float ft = (float)newCap * loadFactor;        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    }    //如果第一次执行才开始对threshold进行初始化    threshold = newThr;    @SuppressWarnings({\"rawtypes\",\"unchecked\"})    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];    //才开始对数组进行初始化    table = newTab;    //这里这个分支意味着不是第一次执行put  因为当是第一次执行put的时候此时oldTab为null    if (oldTab != null) {        for (int j = 0; j &lt; oldCap; ++j) {            Node&lt;K,V&gt; e;            if ((e = oldTab[j]) != null) {                oldTab[j] = null;                if (e.next == null)                    newTab[e.hash &amp; (newCap - 1)] = e;                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                else {                    // preserve order                    Node&lt;K,V&gt; loHead = null, loTail = null;                    Node&lt;K,V&gt; hiHead = null, hiTail = null;                    Node&lt;K,V&gt; next;                    do {                        next = e.next;                        //索引位置没有变                        if ((e.hash &amp; oldCap) == 0) {                            if (loTail == null)                                loHead = e;                            else                                loTail.next = e;                            loTail = e;                        }                        else {                            if (hiTail == null)                                hiHead = e;                            else                                hiTail.next = e;                            hiTail = e;                        }                    } while ((e = next) != null);                    if (loTail != null) {                        loTail.next = null;                        newTab[j] = loHead;                    }                    if (hiTail != null) {                        hiTail.next = null;                        newTab[j + oldCap] = hiHead;                    }                }            }        }    }    return newTab;}\n\n​    扩容的时候一开始要计算新的map容量以及新的扩容阈值，在计算两者的时候分了两种情况，一种就是数组还没有进行初始化，第二种就是原先已经有数据了，如果没有进行初始化就让新的数组的容量等于扩容阈值， newCap = oldThr为什么会是这样呢，因为这里有个小细节那就是hashmap没有容量这个属性，一开始初始化之前是把容量大小计算以后赋值给了阈值这个字段，初始化第一次以后阈值字段存储的才是真正的阈值即执行了 newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY  ?  (int)ft : Integer.MAX_VALUE)。如果进行了初始化那就很明确了就是将原先的容量左移一位同时将阈值字段左移一位。采用位移的方式进行计算是因为乘法运算最终还是会转为位移运算。\n​    第一步计算扩容后的容量以及阈值以后开始进行数据的迁移工作，即将老数组中的数据迁移到新数组中去。在迁移过程中又分为了四种情况，第一种情况就是当前的索引位置的数据为null这种情况我们可以就不做处理，第二种情况就是当前索引位置只有一个数据，没有形成链表，此时我们直接将这个数据迁移到新的数组的位置就可以了。第三种情况就是迁移的数据已经树化形成了红黑树。第四种情况就是普通没有树化的情况。\n​    第四种情况是如何扩容的，如果是普通的链表没有树化的情况下是将链表分为了两部分（高位链、低位链），这个关于高位链和低位链我们来分析一下，假如我们一开始的数组大小为16后来扩容成32，并且我们又两个key（key1，key2）如图：\n\n我们发现当我们在利用位运算取模进行索引值计算的时候如果是16我们会与15（1111）进行与运算这样另外的28位的高位无论是什么值都会是0，也就是索引只去取决于低四位。如果是32那么我们会与31（1 1111）进行与运算，此时的高27位无论是什么值都不有影响，我们发现从16到32其实就是多了一位的取决因素，多的这一位恰好就是十进制的16，所以我们不难想到我们将hash值与原有的容量进行与运算即key.hash&amp;10000如果结果为0则意味着key.hash的第五位上是0不会因为扩容被干扰到所以就会放在低位链里边，但是如果不是0那么意味着会被扩容干扰到索引位置，需要放入到高位链中。通过这样区分了高位链和低位链以后我们将低位链放在新数组的原先位置，高位链放在新数组的原索引加上老数组的容量的位置，以此来摒弃了jdk7的倒置的扩容方式，有效的防止了环链的形成。\n​    第三种情况如果是红黑树的情况下是如何扩容的，我们看下代码:\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {    TreeNode&lt;K,V&gt; b = this;    // Relink into lo and hi lists, preserving order    TreeNode&lt;K,V&gt; loHead = null, loTail = null;    TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;    int lc = 0, hc = 0;    for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {        next = (TreeNode&lt;K,V&gt;)e.next;        e.next = null;        if ((e.hash &amp; bit) == 0) {            if ((e.prev = loTail) == null)                loHead = e;            else                loTail.next = e;            loTail = e;            ++lc;        }        else {            if ((e.prev = hiTail) == null)                hiHead = e;            else                hiTail.next = e;            hiTail = e;            ++hc;        }    }    if (loHead != null) {        if (lc &lt;= UNTREEIFY_THRESHOLD)            tab[index] = loHead.untreeify(map);        else {            tab[index] = loHead;            if (hiHead != null) // (else is already treeified)                loHead.treeify(tab);        }    }    if (hiHead != null) {        if (hc &lt;= UNTREEIFY_THRESHOLD)            tab[index + bit] = hiHead.untreeify(map);        else {            tab[index + bit] = hiHead;            if (loHead != null)                hiHead.treeify(tab);        }    }}\n\n我们可以看出其实在已经树化的链表中其实还是有一个链表存在的，这个链表是为了由树退化成链做出的重要操作，所以我们需要维护这个链表，这个链表的维护方式和上边提到的是一样的都是分为高位链和低位链然后进行迁移，迁移完成以后判断对应链表的长度，如果长度小于等于了6就退化成链表，否则继续重新树化链表形成红黑树。\n产生的并发问题分析：\n因为hashmap线程不安全所以会产生一系列的并发问题，它主要会产生以下的几个问题：\n\nget的时候死锁（形成了环链导致的 jdk8有效的避免了这个问题）。\n\n数据丢失问题：如果多个线程同时操作一个槽位那么就会出现数据覆盖丢失的问题。\nput非null的数据get为null：具体看jdk7中的transfer方法。","url":"/2020/08/16/HashMap源码解析与理解/","link":"","plink":"http://yoursite.com/2020/08/16/HashMap%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%E4%B8%8E%E7%90%86%E8%A7%A3/"},{"title":"Mysql中的MVCC（多版本并发控制）","content":"Mysql中的MVCC（多版本并发控制）Mysql中的MVCC是一个特别难以理解的点，在讲述mvcc之前我们先来简单介绍关于数据库的事务的一点相关知识。\n数据库的事务的特性：\n\n原子性：每个事务都是不可分割的最小执行单位。\n隔离性：每个事务之间是相互隔离互不影响的。\n一致性：在一个事务中的操作要么全部成功要么全部失败。\n持久性：一旦事务结束，执行的结果是持久的。\n\n事务的隔离级别：\n\n读未提交：一个事务读取到另外一个事务还没有提交的结果。\n读已提交：一个事务只会读到另外一个事务提交的结果。（Oracle默认的隔离级别）\n可重复读：在一个事务中第一次读取一个数据的结果和后边读取这个数据的结果是一致的。（mysql默认的隔离级别）\n串行化：所有的事务都是串行执行的，不存在并行的情况。\n\n在上边介绍的四种隔离级别中第一种隔离级别很明显是不对的，最后一种很明显是效率底下的，所以在我们的mysql中基本上不会使用第一种和第四种隔离级别，所以我们接下来主要讨论第二种和第三种隔离级别。我们说到这两种隔离级别以后那么这两种隔离级别是如何实现的，在mysql中其实他就是借助于我们的MVCC来实现的这两种隔离级别。MVCC有两个特别重要的概念就是版本链和readview视图。\n版本链：\n​    对于使用InnoDB存储引擎的表来说，它的聚簇索引记录中都包含两个必要的隐藏列（row_id并不是必要的，我们 创建的表中有主键或者非NULL唯一键时都不会包含row_id列）\n\ntrx_id：每次对某条记录进行改动时，都会把对应的事务id赋值给trx_id隐藏列。 \nroll_pointer：每次对某条记录进行改动时，这个隐藏列会存一个指针，可以通过这个指针找到该记 录修改前的信息。\n\n每个trx_id代表了一个事务，每个rollpointer则指向了当前事务的上一个事务。我们如果有一张user表如图：\n\n​    \n​    图中我们用红色表示已经commit的事务，用绿色表示还没有提交的事务，最开始只有最下边的98号事务并且他是已经提交的，但是当99号事务开始的时候，就会讲roll_pointer指针指向98号事务并且将98号事务的数据放入undo日志中，以方便回滚。此时又来了一个100号事务执行了更新操作，把张三2改为张三3此时100号事务的roll_pointer指向99号事务的数据。同时100号事务没有结束，他又更新了一遍这条数据，此时将张三3改为了张三4，同理他的指针指向了之前的100号事务，此时又来了101号事务对事务进行了更新，指向了之前的100号事务。以上便构成了我们的版本链。\nReadView:\nReadView中主要包含4个比较重要的内容： \n\nm_ids：表示在生成ReadView时当前系统中活跃的读写事务的事务id列表。 \nmin_trx_id：表示在生成ReadView时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小 值。 \nmax_trx_id：表示生成ReadView时系统中应该分配给下一个事务的id值。 \ncreator_trx_id：表示生成该ReadView的事务的事务id\n\n\n注意:max_trx_id并不是m_ids中的最大值，事务id是递增分配的。比方说现在有id为1，2，3这三个事务，之后id为3的事务提交了。那么一个新的读事务在生成ReadView时，m_ids就包括1和2，min_trx_id的值就是1， max_trx_id的值就是3,也就是说这个最大事务id是已经创建的事务id中的最大的id而不是活跃的最大id。\n\n版本链访问规则：\n当另外一个事务进行第一次查询操作的时候会生成这个readview，我们把上图的事务进行readview的生成m_ids就是[98,99,100,101]其中的min_trx_ids为98，max_trx_ids为101，通过最大的id和最小的id我们可以得到如下图的规则。\n\n这样小于最小id的一定是已经提交的事务，大于最大id的一定是没有开始的事务，在最小以及最大的事务id之间的可能是已经提交过的也有可能是没有提交过的，所以我们就可以通过版本链从上向下遍历得到如下的步骤:\n\n如果被访问版本的trx_id属性值与ReadView中的creator_trx_id值相同，意味着当前事务在访问它自 己修改过的记录，所以该版本可以被当前事务访问。 \n如果被访问版本的trx_id属性值小于ReadView中的min_trx_id值，表明生成该版本的事务在当前事 务生成ReadView前已经提交，所以该版本可以被当前事务访问。\n如果被访问版本的trx_id属性值大于ReadView中的max_trx_id值，表明生成该版本的事务在当前事 务生成ReadView后才开启，所以该版本不可以被当前事务访问。 \n如果被访问版本的trx_id属性值在ReadView的min_trx_id和max_trx_id之间，那就需要判断一下 trx_id属性值是不是在m_ids列表中，如果在，说明创建ReadView时生成该版本的事务还是活跃 的，该版本不可以被访问；如果不在，说明创建ReadView时生成该版本的事务已经被提交，该版 本可以被访问\n\n需要注意的是在上图中我们的id是递减的有时候可能因为提交的顺序不一致导致不一定是递减的，如下图：\n\n​    我们既然说过关于读已提交和可重复读都是利用了版本链那么他们有什么区别呢，其实对于读已提交来说，版本链的生成是每一次查询都会生成一个readview，每次都生成一个readview就是及时的更新已经提交的事务，这样就可以读取到已经提交的事务的数据了。而可重复读则是在第一次查询的时候生成readview,这样不会及时更新，可以重复读取数据。\n​    我们上边只是针对修改做了简述，还有就是在删除也会使用到MVCC，其实删除可以作为update的特殊情况，删除时会将版本链上的数据复制一份，然后将trx_id修改成删除操作的trx_id，同时在该条记录的头信息（record header）里的（deleted flag）标记位上写上true，来表示当前的记录已经被删除，在查询的时候按照上边的规则，查到对应的记录，如果deleted flag的数据为true意味着已经被删除不返回数据。\nMVCC总结：    MVCC（Multi-Version Concurrency Control ，多版本并发控制）指的就是在使用READ COMMITTD、 REPEATABLE READ这两种隔离级别的事务在执行普通的SEELCT操作时访问记录的版本链的过程。可以使不同 事务的读-写、写-读操作并发执行，从而提升系统性能。READ COMMITTD、REPEATABLE READ这两个隔离级 别的一个很大不同就是：生成ReadView的时机不同，READ COMMITTD在每一次进行普通SELECT操作前都会 生成一个ReadView，而REPEATABLE READ只在第一次进行普通SELECT操作前生成一个ReadView，之后的查 询操作都重复使用这个ReadView就好了。","url":"/2020/08/16/Mysql中的MVCC（多版本并发控制）/","link":"","plink":"http://yoursite.com/2020/08/16/Mysql%E4%B8%AD%E7%9A%84MVCC%EF%BC%88%E5%A4%9A%E7%89%88%E6%9C%AC%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6%EF%BC%89/"},{"title":"Hello World","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick StartCreate a new post1$ hexo new \"My New Post\"\n\nMore info: Writing\nRun server1$ hexo server\n\nMore info: Server\nGenerate static files1$ hexo generate\n\nMore info: Generating\nDeploy to remote sites1$ hexo deploy\n\nMore info: Deployment","url":"/2020/08/15/hello-world/","link":"","plink":"http://yoursite.com/2020/08/15/hello-world/"},{"title":"三种打家劫舍问题解析","content":"三种打家劫舍问题解析在力扣的题库种右这样一种题目，是一种经典的动态规划类题目。\n\n简单版本的打家劫舍\n你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。\n\n示例 1：\n输入：[1,2,3,1]\n输出：4解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。     偷窃到的最高金额 = 1 + 3 = 4 。\n示例 2：\n输入：[2,7,9,3,1]输出：12解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。     偷窃到的最高金额 = 2 + 9 + 1 = 12 。\n\n\n\n  提示：\n  0 &lt;= nums.length &lt;= 100  0 &lt;= nums[i] &lt;= 400\n  题目解析：\n  ​    这个问题就很简单了，我们思考满足打家劫舍条件的就是两家不能相连，也就是说当打劫到当前店铺的他不能打劫相邻的上一家店铺，所以我们可以建立两个变量，一个用来存放打劫到当前房屋的时候的最大金额，以及打劫到相邻的上家房屋时候的最大金额，而当前房屋的最大金额又是打劫到上上家房屋时的最大金额加上当前金额，并且我们有一个替换过程，当我们继续往下迭代的时候此一次的n-1家的最大金额就等于当前的最大金额，而下个迭代的n-2家的最大金额就是本迭代的n-1家的最大金额，我们不断的进行替换，迭代下去。\n  自己在这个问题中存在的疑问：\n  ​    自己碰到的过不去的点就在于自己本能想到前后都要兼顾不能打劫，意思就是我打劫到当前房屋以后我需要考虑相邻上家不能打劫，相邻下家不能打劫，这就导致了没法继续思考下去，上边的解决方案无疑是比较巧妙的一种解决方式，只考虑打劫到当前房屋时对打劫过来的店铺进行考虑，而不去考虑还未打劫的房屋。\n  代码实现：\n1234567891011121314151617181920212223242526272829303132333435363738394041class Solution {    /**    * 解析：这个问题的关键是要建立一种思路，什么思路呢？    * 要这样思考就是要考虑如果打劫这家店铺需要什么条件？    * 打劫这家店铺就不能够打劫它相邻的上一家店铺，有人可能会说    * 他的下一家也不能打劫，但是我们想，当我们打劫到下一家的时候是不是同样的不能打劫上一家    * 接下来要考虑另外一个问题：    * 我们打劫到当前店铺以后所获取的钱应该是之前n-2家店铺的获取的钱的最大值加上当前店铺的钱    * 我们不能够直接去考虑到底有多少种打劫方式。那样会极为复杂    */    public int rob(int[] num) {       int n_2=0;//前n-2家店的最大钱数       int n_1=0;//第n_1家店的最大钱数  如果我们不打劫当前店铺那么此时最大的钱数就是前n-1家的最大值       for(int i=0;i&lt;num.length;i++){           int temp=n_1;           n_1=Math.max(n_2+num[i],n_1);//把前n-2的数据和当前的数据相加  然后与前n-1家的最大值做比较           n_2=temp;//下一次循环的时候n-2就会等于这次的n-1       }       return n_1;    }}\n\n\n稍微复杂的打家劫舍问题解析\n你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都围成一圈，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。\n给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。\n\n示例 1:\n输入: [2,3,2]输出: 3解释: 你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。示例 2:\n输入: [1,2,3,1]输出: 4解释: 你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。     偷窃到的最高金额 = 1 + 3 = 4 。\n​\n\n​    和简单版本不同的是这次所有的房屋是围成圈的，有一个思路，如果我们选择了第一个家就不能选择最后一家，如果我们选择了最后一家就不能选择第一家，当然我们可以第一家和最后一家都不选，但是这样我们肯定没有前两种情况打劫的钱多，所以我们只考虑前两种即可，基于前两种情况的考虑我们可以将环形的数组分为两个单向的数组，即索引位0到（n-2）和1到（n-1）然后我们利用普通版的打家劫舍代码分别去计算这两种情况然后取最大值就可以了，所以我们就可以得到我们的代码。\n代码实现\n123456789101112131415161718192021222324252627282930313233343536373839class Solution {    public int rob(int[] nums) {         if(nums.length==1){            return nums[0];        }        if(nums.length==0){            return 0;        }        return Math.max(rober(nums,0,nums.length-2),rober(nums,1,nums.length-1));    }    public int rober(int[] nums,int start,int end){        //到达上一个最大钱数        int n_1=0;        //到达上上个的最大钱数        int n_2=0;        for(int i=start;i&lt;=end;i++){            int temp=n_1;            n_1= Math.max(n_2+nums[i],n_1);            n_2=temp;        }        return n_1;    }}\n\n​\n\n终极打家劫舍问题\n在上次打劫完一条街道之后和一圈房屋后，小偷又发现了一个新的可行窃的地区。这个地区只有一个入口，我们称之为“根”。 除了“根”之外，每栋房子有且只有一个“父“房子与之相连。一番侦察之后，聪明的小偷意识到“这个地方的所有房屋的排列类似于一棵二叉树”。 如果两个直接相连的房子在同一天晚上被打劫，房屋将自动报警。\n计算在不触动警报的情况下，小偷一晚能够盗取的最高金额。\n\n示例 1:\n输入: [3,2,3,null,3,null,1]\n12345  3 / \\2   3 \\    \\    3     1\n\n输出: 7解释: 小偷一晚能够盗取的最高金额 = 3 + 3 + 1 = 7.示例 2:\n输入: [3,4,5,1,3,null,1]\n12345    3   / \\  4   5 / \\   \\ 1   3   1\n\n输出: 9解释: 小偷一晚能够盗取的最高金额 = 4 + 5 = 9.\n\n​    最后一种打家劫舍问题其实也不难，只不过转化了一下思路而已，之前是相邻两家房屋不能打劫，现在是相同相邻的两层房子不能打劫而已，所以我们的计算方法是一样的只不过是在计算每一层所能够打劫到的钱财时稍许复杂。\n\n代码实现\n1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Definition for a binary tree node. * public class TreeNode { *     int val; *     TreeNode left; *     TreeNode right; *     TreeNode(int x) { val = x; } * } */class Solution {    //建立一个备忘录，用来记录打劫到某个节点的时候的最大钱数，以此来减少重复操作    Map&lt;TreeNode,Integer&gt;  map=new HashMap&lt;&gt;();    public int rob(TreeNode root) {        if(root==null){return 0;}        if(map.containsKey(root)){            return map.get(root);        }        //n-2层的最大钱数        int n_2=0;        //n-1层的最大钱数        int n_1=0;        //判断为null的情况        int val=root==null?0:root.val;        int temp=n_1;        //这一层的加上下下层的最大钱数        n_1=Math.max(val+(root.left==null?0:(rob(root.left.left)+rob(root.left.right)))               +(root.right==null?0:(rob(root.right.left)+rob(root.right.right))),               rob(root.right)+rob(root.left));        n_2=temp;        map.put(root,n_1);        return n_1;    }}\n\n​","url":"/2020/08/16/三种打家劫舍问题解析/","link":"","plink":"http://yoursite.com/2020/08/16/%E4%B8%89%E7%A7%8D%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E9%97%AE%E9%A2%98%E8%A7%A3%E6%9E%90/"},{"title":"不同的二叉搜索树（96题）","content":"不同的二叉搜索树（96题）给定一个整数 n，求以 1 … n 为节点组成的二叉搜索树有多少种？\n示例:\n12345678910输入: 3输出: 5解释:给定 n = 3, 一共有 5 种不同结构的二叉搜索树:1         3     3      2      1 \\       /     /      / \\      \\  3     2     1      1   3      2 /     /       \\                 \\2     1         2                 3\n题解：&nbsp;&nbsp;首先理解题目意思这是一个二叉搜索树，二叉搜索树就是对于一个根节点而言他的左子节点一定比他小，他的右子节点一定比他大。\n假如说我们给到的整数是5，那么对于[1,2,3,4,5]这个递增数组来说，如果以3为根节点，那么1，2一定在其左边，4，5一定在其右边。同时每个节点都有作为根节点的可能，其实这时我们可以组成的二叉搜索树的数量就是左边元素可以组成的二叉搜索树的数量x右边元素可以组成的二叉搜索树的数量，这其实是一种笛卡尔积。既然我们要利用动态规划来解决这个问题，那么此时如果我们有n个元素以i元素为根元素，那么我们得到的二叉搜索树的数量就是0-i能够组成的所有的二叉搜索树x(n-i)个元素组成的二叉搜索树的个数。动态转移的方程我们已经得到，那么我么就可以从0开始向后遍历，把从只有0个元素的数组到有n个元素的数组依次计算，然后内层循环遍历每个元素作为根节点的情况。此时我们还需要考虑如果n=0或者n=1我们很容易得到结果，就是1种和1种。那么我们可以定义动态规划的数组dp[n+1]。\n我们的计算过程如下：\n1234567891011121314151617181920212223242526class Solution {  \tpublic int numTrees(int n) {\t      //这个动态规划数组的含义就是：dp[i]代表了n==i的时候共有几种二叉搜索树\t int[] dp = new int[n+1];              //如果有0个元素那么就是一棵空树也是一种情况\t    dp[0] = 1;        dp[1] = 1;          //最外层的循环是用来控制有多少个数字的      //i的值就是有i个元素，通过这样的方式我们可以不断的向后计算直到计算出我们传入的值   \t for(int i = 2; i &lt; n + 1; i++){       //j是用来控制根节点元素的，在1-j间每个元素都有可能作为根节点        for(int j = 1; j &lt; i + 1; j++){                      dp[i] += dp[j-1] * dp[i-j];        }             }    \t      return dp[n];  \t}}\n\n动态规划的精髓就是后边我们需要的结果一定时依赖于前边的计算结果的。除此之外他与分治算法非常相似，就是将待求解问题分解成若干个子问题，然后从这些子问题种得到原问题的解。比如上边的问题种，我们需要求n个数据是可以组成的二叉搜索树的个数，那么我们可以分解成左边元素组成的个数乘以右边元素所组成的个数，同时我们不直接计算n个元素而是我们从0个元素往后计算直至推导出我们想要的n个元素的结果。","url":"/2020/08/16/不同的二叉搜索树（96题）/","link":"","plink":"http://yoursite.com/2020/08/16/%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%8896%E9%A2%98%EF%BC%89/"},{"title":"力扣464题我能赢吗","content":"力扣464题我能赢吗题目描述：\n在 “100 game” 这个游戏中，两名玩家轮流选择从 1 到 10 的任意整数，累计整数和，先使得累计整数和达到 100 的玩家，即为胜者。\n如果我们将游戏规则改为 “玩家不能重复使用整数” 呢？\n例如，两个玩家可以轮流从公共整数池中抽取从 1 到 15 的整数（不放回），直到累计整数和 &gt;= 100。\n给定一个整数 maxChoosableInteger （整数池中可选择的最大数）和另一个整数 desiredTotal（累计和），判断先出手的玩家是否能稳赢（假设两位玩家游戏时都表现最佳）？\n你可以假设 maxChoosableInteger 不会大于 20， desiredTotal 不会大于 300。\n示例：\n\n输入：\nmaxChoosableInteger = 10desiredTotal = 11\n输出：false\n解释：无论第一个玩家选择哪个整数，他都会失败。第一个玩家可以选择从 1 到 10 的整数。如果第一个玩家选择 1，那么第二个玩家只能选择从 2 到 10 的整数。第二个玩家可以通过选择整数 10（那么累积和为 11 &gt;= desiredTotal），从而取得胜利.同样地，第一个玩家选择任意其他整数，第二个玩家都会赢。\n\n题解：\n看题目需求是要看看第一个玩家能不能赢，所以我们只需要直到有没有一种情况能够使他获胜就可以了。找到一宗情况就可以返回了，在解题种使用了记忆化回溯的方法（也称之为递归+备忘录），他是动态规划的一种，我们既然是记忆那么记忆的是什么数据，我们需要记忆的是一种情况，假设我们先选择了2然后第二次选择了3这种情况其实和我们第一次先选择了3然后第二次选择2是一样的效果，所以我们需要对其中一种情况进行记录，并将其放入map种每次进来我们先去判断map种存不存在相同的情况，那么我们想我们的key是什么呢，我们可以定义一个数组，这个数组只存放1或者0如果是1则代表了该位置的数据被访问过了，如果是0则表示第一次被访问，通过这个数组我们可以控制数据只被访问一次，同时我们利用这个数组转为字符串作为map的key，value就是能否赢得胜利，上边的选择2,3的两种情况其实都可以用011来作为key。\n再来看我们对于递归的解析，假设传入的累计和位10且玩家1选择了1这个数字，那么还剩下2-10这几个数字玩家2选择，也就是我们题目转换成了玩家2从2-10种选择一个数字看是否能够取得胜利，假设当玩家2 选择了2这个数字，那么玩家1就需要从3-10种选择出某个数字来看能够取得胜利，依次类推下去。我们发现可以使用递归的方式来解决这个问题，因为这时除了选择数据的区间不一样其余的都是一样的效果。\n我们再来看玩家1赢得胜利的条件是什么，玩家1在选择了某个值后能够赢得胜利的条件就是此时累计和已经达到要求了，或者是对方在剩余的区间选择种输了，可能会有疑问，为什么玩家2输了，玩家1一定会赢呢，因为我们做了判断我们的数组的累计和一定比需要的累计和大，所以这就变成了一个非赢即输的游戏。\n代码示例\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 public class Solution {    /**     * 记忆化回溯（也称为递归+备忘录），自顶向下     * 采用记忆化后的时间复杂度为O(2^n)(如果不进行记忆的话，时间复杂度将是O(n!))，可以理解为已经缩成了只有一个分支了     * 然后为什么要进行记忆化：     * 因为我们发现，例如[2,3]和[3,2]之后的玩家选择状态都是一样的，都是可以从除了2,3之外的     * 数字进行选择，那么就可以对选择2和3后第一个玩家能不能赢进行记忆存储     * 这里采用state[]数组存储每个数字是否都被选过，选过则记录为1，然后我们将state.toString()     * 使得[2,3]和[3,2]它们的结果都是一样的\"0011\"，作为key，存储在HashMap中，value是选了2和3     * 之后第一个玩家是否稳赢     * @param maxChoosableInteger     * @param desiredTotal     * @return     */    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {        if (maxChoosableInteger &gt;= desiredTotal) return true;        //1,..maxChoosable数列总和都比目标和小        if ((1 + maxChoosableInteger) * maxChoosableInteger / 2 &lt; desiredTotal) return false;         //state[1]=1表示1被选了        int[] state = new int[maxChoosableInteger + 1];         return backtraceWitMemo(state, desiredTotal, new HashMap&lt;String, Boolean&gt;());            }    private boolean backtraceWitMemo(int[] state, int desiredTotal, HashMap&lt;String, Boolean&gt; map) {         //这里比较关键，如何表示这个唯一的状态，例如[2,3]和[3,2]都是\"0011\"，状态一样        String key = Arrays.toString(state);        //如果已经记忆了这样下去的输赢结果,记忆是为了防止如[2,3]，[3,2]之后的[1,4,5,..]这个选择区间被重复计算        if (map.containsKey(key)) return map.get(key);          for (int i = 1; i &lt; state.length; i++){            if (state[i] == 0){ //如果这个数字i还没有被选中                state[i] = 1;                //如果当前选了i已经赢了或者选了i还没赢但是后面对方选择输了                if (desiredTotal - i &lt;= 0 || !backtraceWitMemo(state, desiredTotal - i, map)) {                    map.put(key, true);                         //在返回之前回溯                    state[i] = 0;                    return true;                }                    //如果不能赢也要记得回溯                state[i] = 0;                }            }        //如果都赢不了            map.put(key, false);        return false;        }}","url":"/2020/08/16/力扣464题我能赢吗/","link":"","plink":"http://yoursite.com/2020/08/16/%E5%8A%9B%E6%89%A3464%E9%A2%98%E6%88%91%E8%83%BD%E8%B5%A2%E5%90%97/"},{"title":"十大排序算法","content":"十大排序算法\n简单选择算法\n12345678910111213141516171819202122public static void selectSort(int[] arr) {         int minINdex = 0;       int temp;       for (int i = 0; i &lt; arr.length; i++) {                    for (int j = i + 1; j &lt; arr.length; j++) {               if (arr[i] &gt; arr[j]) {                   minINdex = j;               }           }           //此时不是最小值进行交换           if (minINdex != i) {               temp = arr[minINdex];               arr[minINdex] = arr[i];               arr[i] = temp;           }       }   }\n\n\n\n简单选择排序算法的思路就是进行嵌套的循环遍历，然后找出最小值，进行外层循环的值的替换。排序比较简单不多详细讲解。\n\n快速排序\n12345678910111213141516171819202122232425262728293031323334353637383940414243public static void quickSort(int[] arr, int start, int end) {        if (start&gt;=end){            return;        }        //以第零个元素作为基准数        int stander = arr[start];        int low = start;        int high = end;        while (low &lt; high) {            //如果右边的数组比标准数据大此时不需要交换，只需要将坐标往前移            while (low &lt; high &amp;&amp; stander&lt;= arr[high]) {                high--;            }            //如果没有比标准数据大此时就可以用右边的数据替换左边的数据            arr[low] = arr[high];            //此时经过上边的操作坐标已经移到了数组的左边，所以可以从左边开始遍历了            while (low &lt; high &amp;&amp; arr[low] &lt;= stander) {                low++;            }            //但是如果左边的数据没有比右边的大，此时需要交换            arr[high] = arr[low];        }          if (low == high) {                        //把标准数据赋值给低（高）所在的位置，需要注意的是此时高位和低位已经重合了            arr[low] = stander;            //左边的数据和右边的数据分别进行递归调用            quickSort(arr, start, low);            //右边的数据进行递归调用            quickSort(arr, low + 1, end);        }    }\n\n\n\n快速排序的过程就是，以最开始的元素位标准，然后当开始元素小于最大元素的时候，就一直循环，如果右边高位的数据比标准数大那么此时就将高位的指针左移，直到找到了标准数据大于了右边的高位的数据，然后将高位的数据换到左边最低位，此时我们应该从左侧开始循环了，然后依然取判断左侧的数据和标准值的关系，只要是小于标准值，那么就让低位的指针右移一位，直到两个高位和低位的指针重合，然后把标准值赋值给重合位置的数据，然后以重合位置位中点将数组分为两个部分，进行递归调用。这里的思路就是以开始坐标为基准将比基准值小的都收集到左侧，比基准值大的都收集到右侧，依次分割递归执行。\n\n直接插入排序\n1234567891011121314151617181920212223242526public static void insertSort(int[] arr) {    int temp;    for (int i = 0; i &lt; arr.length; i++) {        //如果当前数字比前一个小才会进行排序        if (arr[i] &lt; arr[i - 1]) {            temp = arr[i];            int j;            for (j = i - 1; j &gt;= 0; j--) {                if (arr[j] &lt;= temp) {                    break;                }            }            arr[j + 1] = temp;        }    }}\n\n\n\n直接插入排序的思路就是认为前边的数据是排好序的，比如对于[3,6,4,1,9,0]这个数组来说，认为随着遍历前边的数据已经排好序，从一开始遍历第一个元素，然后遍历其后边的元素，如果发现比前边的元素大则不做任何操作，但是如果发现比前边的元素小，那么当前元素就要往前移动，这个移动就是要和前边的所有的元素依次比较。直到找到比自己小的元素，然后中断内层循环，然后进行替换。\n\n希尔排序\n123456789101112131415161718public static void shellSort(int[] arr) {    //开始的步长为数组长度除以2，每次循环都要除以2    for (int d = arr.length / 2; d &gt; 0; d /= 2) {        //遍历所有的元素        for (int i = d; i &lt; arr.length; i++) {            //遍历本组的元素            for (int j = i - d; j &gt;= 0; j -= d) {                //把本组中大的值交换到后边，小的值交换到前边                if (arr[j] &gt; arr[j + d]) {                    int temp = arr[j];                    arr[j] = arr[j + d];                    arr[j + d] = temp;                }            }        }    }}\n\n\n\n希尔排序其实是属于插入排序，其实对数组进行了分组，比如对于数组[3,6,4,1,9,0],分组开始的步长就是数组的长度除以二，此处得到的d就是我们的步长，其实会发现步长是不断在变短的，我们会将数组分割然后进行两两比较替换。\n\n归并排序\n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445public static void merge(int start, int end, int[] old, int[] temp) {    if (start &lt; end) {        int midle = (end + start) / 2;        merge(start, midle, old, temp);        merge(midle + 1, end, old, temp);        merageSort(start, end, midle, old, temp);    }}public static void merageSort(int start, int end, int midle, int[] old, int[] temp) {  int p1 = start;  int p2 = end;  int p3 = midle + 1;  int index = 0;  while (p1 &lt; midle &amp;&amp; p3 &lt; p2) {      if (old[p1] &lt; old[p3]) {          temp[index] = old[p1];          p1++;      } else {          temp[index] = old[p3];          p3++;      }      index++;  }  if (p1 &lt; midle) {      for (int i = p1; i &lt; midle; i++) {          temp[index] = old[p1];          index++;      }  }  if (p2 &lt; p3) {      for (int i = p2; i &lt; p3; i++) {          temp[index] = old[p2];          index++;      }  }  for (int j = 0; j &lt; temp.length; j++) {      old[start + j] = temp[j];  }   }\n\n归并排序其实利用了分治算法的思想分而治之，我们来假设有两个有序数组[1,3]和[2,4]我们如果将这两个数组合并成一个数组并且排序，我们从比较这两个数组的第一个元素发现较小的是1，然后我们将1放入新的数组中，之后就是2然后比较第二个元素我们发现比较小的是3，然后新数组的第三个元素就是3，最后一个元素就是4，就这样我们将这两个数组合并成一个数组并且排序，如果将这种思想利用到我们的数组排序上，那就是将数组不断切割直至分成独立的单个元素我们可以把每一个单个元素看作有序的数组，然后我们搞一个新的数组不断的往新数组中存放数据，但是我们在排序的过程中要判断一个特殊的状态就是分开的两个子数组可能会出现某个数组特别长，导致另外一个数组已经遍历完成了，但是长数组还有数据没有遍历，那么我们可以直接将长数组的元素放在新数组的后边。\n\n冒泡排序 \n12345678910111213141516171819202122232425262728/** * 冒泡排序 * * @param array */private static void bubbleSort(int[] array) {    int temp;    for (int i = 0; i &lt; array.length; i++) {        for (int j = i + 1; j &lt; array.length; j++) {            if (array[i] &gt; array[j]) {                temp = array[j];                array[j] = array[i];                array[i] = temp;            }        }    }}\n\n\n\n冒泡排序是一种比较简单的排序算法，原理就是我们进行了嵌套循环，我们不断的比较挑出最大的元素往后移动直到数组最后的位置，就像冒泡一样不断向上。\n\n基数排序\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546/**    * 基数排序的队列实现    * 基数排序适合于数据位数不一样的数据进行排序    */   public static void baseSortByQueue(int[] arr) {       int maxData = arr[0];       for (int i = 1; i &lt; arr.length; i++) {           if (maxData &lt; arr[i]) {               maxData = arr[i];           }       }       Queue&lt;Integer&gt;[] myqueue = new LinkedBlockingDeque[9];       int length = (maxData + \"\").length();       for (int j = 0, n = 1; j &lt;= length; j++, n = n * 10) {           for (int l = 0; l &lt; arr.length; l++) {               int index = arr[l] / n % 10;               myqueue[index].offer(arr[l]);           }       }       int index = 0;       for (int m = 0; m &lt; myqueue.length; m++) {           while (!myqueue[m].isEmpty()) {               arr[index] = myqueue[m].poll();               index++;           }       }   }\n\n\n\n\n\n桶排序\n1234567891011121314151617181920212223242526272829303132333435363738public static void bucketSort(int[] arr) { //找出数组中的最大元素和最小元素  int min = arr[0];  int max = arr[0];  for (int i = 0; i &lt; arr.length; i++) {      max = Math.max(max, arr[i]);  }  //计算桶的个数  int length = (max - min) / arr.length + 1;  //为了计算简单此处不再使用二维数组，直接采用list嵌套list的形式来进行存储  List&lt;ArrayList&lt;Integer&gt;&gt; arrayLists = new ArrayList&lt;&gt;(length);  //开始构建length个桶  for (int j = 0; j &lt; length; j++) {      arrayLists.add(new ArrayList&lt;&gt;());  }  // 将每个元素放入桶  for (int i = 0; i &lt; arr.length; i++) {      int num = (arr[i] - min) / (arr.length);      arrayLists.get(num).add(arr[i]);  }  // 对每个桶进行排序  for (int i = 0; i &lt; arrayLists.size(); i++) {      Collections.sort(arrayLists.get(i));  }  // 将桶中的元素赋值到原序列  int index = 0;  for (int i = 0; i &lt; arrayLists.size(); i++) {      for (int j = 0; j &lt; arrayLists.get(i).size(); j++) {          arr[index++] = arrayLists.get(i).get(j);      }  }   }\n\n\n\n\n桶排序的实现思路也比较简单，他是一种以空间换取时间的算法实现，这种排序算法的局限性也是比较大的，它适用于数组元素的最大值和最小值相差不是非常大的情况（也就是所说的数据比较集种的情况），就是用最大元素减去最小元素\n\n计数排序\n1234567891011121314151617181920212223242526272829303132333435363738public static void countSort(int[] arr) {    //找出数组中的最大元素和最小元素    int min = arr[0];    int max = arr[0];    for (int i = 0; i &lt; arr.length; i++) {        if (arr[i] &lt; min) {            min = arr[i];        }        if (arr[i] &gt; max) {            max = arr[i];        }    }    //得出对应的数组的长度    int d = max - min;    //创建统计数组  并计算统计对应元素个数    int[] countArray = new int[d + 1];    for (int j = 0; j &lt; arr.length; j++) {        countArray[arr[j] - min]++;    }    //对统计数组进行变形 后边的元素等于前边的元素之和    int sum = 0;    for (int m = 0; m &lt; countArray.length; m++) {        sum += countArray[m];        countArray[m] = sum;    }    //对原始数组倒序    int[] sortArray = new int[arr.length];    for (int i = 0; i &lt;= arr.length - 1; i++) {        sortArray[countArray[arr[i] - min] - 1] = arr[i];        countArray[arr[i] - min]--;    }    System.arraycopy(sortArray, 0, arr, 0, sortArray.length);}\n\n堆排序\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879/** * 堆排序代码实现 * &lt;p&gt; * 顺序存储的二叉树有这么几个特点(通常只考虑完全二叉树)： * &lt;p&gt; * 第n个元素的左子节点为2*n+1 * 第n个元素的右子节点为2*n+2 * 第n个元素的父节点为(n-1)/2 */public static void heapSort(int[] arr) {    //计算开始位置，从最后一层叶子节点的父节点开始遍历  因为是要索引所以-2    int start = (arr.length - 2) / 2;    //第一次首先将其调整为大顶堆    for (int i = start; i &lt; arr.length - 1; i++) {        heapMax(arr, arr.length, i);    }    for (int i = arr.length - 1; i &gt;= 0; i--) {        int temp = arr[i];        arr[i] = arr[0];        arr[0] = temp;        //因为第一次操作以后已经构成了大顶堆，所以每次可以从0向后进行调整        heapMax(arr, i, 0);    }}/** * 找出大顶堆 * &lt;p&gt; * 顺序存储的二叉树有这么几个特点(通常只考虑完全二叉树)： * &lt;p&gt; * 第n个元素的左子节点为2*n+1 * 第n个元素的右子节点为2*n+2 * 第n个元素的父节点为(n-1)/2 */public static void heapMax(int[] arr, int size, int index) {    if (index &lt; size) {        //找出左子树和右子树的位置坐标        int leftNode = 2 * index + 1;        int rightNode = 2 * index + 2;        //一开始默认当前节点为最大值        int max = index;        if (leftNode &lt; size &amp;&amp; arr[max] &lt; arr[leftNode]) {            max = leftNode;        }        if (rightNode &lt; size &amp;&amp; arr[max] &lt; arr[rightNode]) {            max = rightNode;        }        if (max != index) {            int temp = arr[max];            arr[max] = arr[index];            arr[index] = temp;            //这次交换可能导致了其子树的结构变化所以需要重新进行排序            heapMax(arr, size, max);        }    }}","url":"/2020/08/16/十大排序算法/","link":"","plink":"http://yoursite.com/2020/08/16/%E5%8D%81%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"},{"title":"背包九讲","content":"背包九讲​    动态规划解题步骤（问题抽象化、建立模型、寻找约束条件、判断是否满足最优性原理、找大问题与小问题的递推关系式、填表、寻找解组成）。\n\n01背包问题\n题目：有N件物品和一个容量为V的背包。第i件物品的重量是c[i]，价值是w[i]。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。\n​    利用动态规划解决这个问题，首先就是要找出其中的前后依赖关系，我们要找到状态转移方程，我们需要将问题进行拆解，既然有N件物品且重量为V我们不要直接去考虑这个全部的问题，我们去分析依次将每个物品分别放入1-v重量的背包时候的最大价值。假如我们的物品有三件分重量分别是[1,4,3]价值分别为[1500,3000,2000],背包的容量为4我们可以通过思路建立一个表格，表格的左侧表示的是物品的质量，表格的上方表示的是背包的重量，虽然背包的容量为6，但是我们要去分析，背包质量从1到4的全部最大价值，因为我们在最后求我们需要的值的时候是依赖前边结果的。\n\n\n\n\n1\n2\n3\n4\n5\n6\n\n\n\n1\n1500\n1500\n1500\n1500\n1500\n1500\n\n\n4\n1500\n1500\n1500\n1500\n4500\n4500\n\n\n3\n1500\n1500\n1500\n3500\n4500\n4500\n\n\n​    我们来分析下这个表格的含义，当背包的容量为1的时候我们放入第一个物品此时最大价值就是1500，同理当背包容量分别为2，3，4，5，6的时候最大价值也是1500，当我们放入第二个物品的时候如果背包容量为1，我们此时放不进去第二个物品，在此时我们所获得的最大价值其实还是放入第一个物品的时候的最大价值即1500，同理一直到背包容量为4的时候我们都放入不了第二个物品，但是当背包容量为5的时候不一样了，第二个物品可以放入了，因为此时5-1=1我们发现第一个物品可以和第一个物品相容，我们此时获取的最大价值应该是1500+3000=4500所以此时最大的价值就是4500，同样当背包容量为6的时候也是4500的价值，因为6-4=2，虽然得出来此时可以放入第二个物品但是我们的物品不能重复放入，所以当我们分析放入第三个物品的时候同样一直到背包容量为3我们都放入不了第三个物品，到了背包容量为4的时候我们通过计算4-3=1得到此时可以入第一个物品，也就是在容量为4的时候可以放入第一个和第三个物品那么此时的最大重量为1500+2000=3500，3500显然比放入第二个物品时的2500大所以在背包容量为4的时候放入第三个物品的时候的最大价值为3500，由此如果我们创建一个二位数组$dp[i][j]$ 其中的$i$就代表了物品的数量，j代表了背包容量那么我们可以得出状态转移方程式：$dp[i][j]=Math.max(dp[i-1][j],dp[i-c[i]][j]+v[i])$ 其中$i&gt;=c[i]$ 。\n通过上边的分析我们可以得出代码试下：\n1public class PackageProblem01 {\n\n\n\n\n   public static void main(String[] args) {\n\n       //定义三个物品的重量\n       int[] weight = {1, 4, 3};\n\n       //定义三个物品的价值\n       int[] value = {1500, 3000, 2000};\n\n       //定义一共有多少个物品\n       int n = value.length;\n\n       //定义背包所能够承载的最大重量\n       int m = 4;\n\n       //定义一个二维数组，这个数组用来存放,dp[i][j]代表了当第i个物品放入容量为j的背包中以后的价值，\n       //需要注意的是此时的背包的容量是变化的，因为随着放入背包的物品的增加背包的剩余容量是不断变小的，所以\n       //通过逆向思维考虑，背包的容量随着物品的增加可以是不断增大的，直到到达了最大的容量\n       int[][] dp = new int[n + 1][m + 1];\n\n       //双层循环，最外层是物品的循环内层是容量的循环\n       for (int i = 1; i &lt; dp.length; i++) {\n\n           for (int j = 1; j &lt; dp[0].length; j++) {\n\n               //此时分为了两种情况，当想要放入物品的重量已经超出了剩余的背包容量，那么此时就直接获取到放置上一个物品的时候的最大价值\n               //此时上一个物品的最大价值就是在这个物品放入时的最大价值。j此时就代表了重量 i是从1开始的。所以用weight[i-1]\n               if (weight[i - 1] &gt; j) {\n                   dp[i][j] = dp[i - 1][j];\n               } else {\n\n                   //想要存储放入背包的物品需要拆开上边的公式。\n                   if (dp[i - 1][j] &lt; value[i - 1] + dp[i - 1][j - weight[i - 1]]) {\n                       //意味着此时需要将当前物品放入背包\n                       dp[i][j] = value[i - 1] + dp[i - 1][j - weight[i - 1]];\n\n                   } else {\n\n                       dp[i][j] = dp[i - 1][j];\n                   }\n\n               }\n\n           }\n       }\n       for (int i = 0; i &lt; dp.length; i++) {\n\n           System.out.println(Arrays.toString(dp[i]));\n\n       }\n\n   }\n   }   123456789101112131415161718192021222324252627282930313233343536优化以后的01背包问题：&#96;&#96;&#96;javapublic class PackageProblem01Upgrage {    public static void main(String[] args) {        &#x2F;&#x2F;定义三个背包的重量        int[] weight &#x3D; {1, 4, 3};        &#x2F;&#x2F;定义三个背包的价值        int[] value &#x3D; {1500, 3000, 2000};        &#x2F;&#x2F;定义一共有多少个物品        int n &#x3D; value.length;        &#x2F;&#x2F;定义背包所能够承载的最大重量        int m &#x3D; 4;        int[] dp &#x3D; new int[m + 1];        for (int i &#x3D; 0; i &lt; weight.length; i++) {            for (int j &#x3D; m; j &gt;&#x3D;value[i]; j--) {                 dp[j] &#x3D; Math.max(dp[j], dp[j - weight[i]] + value[i]);            }        }        System.out.println(dp[m]);    }}\n   优化后的代码只是将原先用的二维数组改为了一维数组，降低了空间复杂度，我们对于优化后的代码会产生两个疑问，一就是为什么我们可以改为一维数组，那是因为我们之前的代码中会发现$dp[i][j]$ 只与上一个元素有关系，所以我们完全利用滚动数组，每次数组中的数据都存储上一次的最大值，这样我们就可以用一维数组表示了。第二就是我们改为了一维数组为什么内层循环使用了从后向前遍历的方式，那是因为我们需要对$j&lt;weight[i]$ 的情况进行处理，如果我们从前往后遍历我们后边的数据要依赖于前边的数据，就针对$weight[1]$ 来说，在正向遍历的过程中$dp[i]$ 是不断赋值的，这样如果使用动态转移方程式我们如果最终找到$j-weight[i]$ 的值它是被改变了的，他已经不是0了所以我们使用$dp[j - weight[i]] + value[i]$ 就会造成数据偏大的问题。倒序遍历就是为了保证前边的值不变还是上一伦的数据，因为我们依赖$j-weight[i]$ 而这个值在这一轮中不可以变才行，所以此时只有从后往前遍历才会解决这个问题。\n\n完全背包问题\n题目：有N种物品和一个容量为V的背包，每种物品都有无限件可用。第$i$种物品的费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。\n​    完全背包问题的最大特点就是物品可以重复使用，其实完全背包问题可以转化为01背包问题来求解，完全背包的物品可以重复利用那么我么其实可以以01背包为基础，只不过每次再遍历的时候我们加一层分析就是关于放入同一个物品数量的分析，可以通过加一层循环的方式解决，就是计算出当放入一个时的最大价值，放入两个时的最大价值，直到放入的物品的质量超过总质量为止，这就是完全背包的思路了，此时完全背包的状态转移方程为$dp[i][j]=Math.max(dp[i-1][j],dp[i-kc[i]][j]+kv[i])$ 。\n代码实现如下：\n1234567891011121314151617public class PackageProblemComplete {    public static void main(String[] args) {        //定义三个背包的重量        int[] weight = {1, 4, 3, 5};        //定义三个背包的价值        int[] value = {1500, 3000, 2000, 5000};        //定义一共有多少个物品        int n = value.length;        //定义背包所能够承载的最大重量        int m = 10;        int[][] dp = new int[n + 1][m + 1];\n\n\n\n\n       //完全背包问题无非就是商品可以重复选择，此时需要在原来的基础上进行多一次的循环，就是对于选择的商品数量进行循环\n       for (int i = 1; i &lt; dp.length; i++) {\n\n           for (int j = 1; j &lt; dp[0].length; j++) {\n\n               for (int k = 0; k * weight[i-1] &lt; j; k++) {\n\n                   dp[i][j] = Math.max(dp[i - 1][j], value[i-1] + dp[i - 1][j - k * weight[i - 1]]);\n\n               }\n\n           }\n\n       }\n\n       for (int i = 0; i &lt; dp.length; i++) {\n\n           System.out.println(Arrays.toString(dp[i]));\n\n       }\n\n   }\n   }   12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758   ​3. **多重背包问题**   题目：   有N种物品和一个容量为V的背包。第$i$种物品最多有$n[i]$件可用，每件费用是$c[i]$，价值是$w[i]$。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。   ​\t多重背包也没有什么难度，其实就是完全背包的变种，之前沃我们限制物品的数量k，使得$k * weight[i-1] &lt; j$ 我们想要实现多重背包只需要将这个公式改一下就可以了，即$k&lt;n[i]$ 原有的逻辑不变这样就可以解决多重背包问题。    &#96;&#96;&#96;java   public class PackageProblemMultiple {             public static void main(String[] args) {           &#x2F;&#x2F;定义三个物品的重量           int[] weight &#x3D; {1, 4, 3, 5};           &#x2F;&#x2F;定义三个物品的价值           int[] value &#x3D; {1500, 3000, 2000, 5000};           &#x2F;&#x2F;定义三种物品的最大数量           int[] num&#x3D;{2,4,1,4};           &#x2F;&#x2F;定义一共有多少个物品           int n &#x3D; value.length;           &#x2F;&#x2F;定义背包所能够承载的最大重量           int m &#x3D; 10;           int[][] dp &#x3D; new int[n + 1][m + 1];           &#x2F;&#x2F;完全背包问题无非就是商品可以重复选择，此时需要在原来的基础上进行多一次的循环，就是对于选择的商品数量进行循环           for (int i &#x3D; 1; i &lt; dp.length; i++) {               for (int j &#x3D; 1; j &lt; dp[0].length; j++) {                   for (int k &#x3D; 0; k &lt;num[i-1]&amp;&amp;j&gt;k * weight[i - 1]; k++) {                       dp[i][j] &#x3D; Math.max(dp[i - 1][j], value[i-1] + dp[i - 1][j - k * weight[i - 1]]);                   }               }           }           for (int i &#x3D; 0; i &lt; dp.length; i++) {               System.out.println(Arrays.toString(dp[i]));           }       }          }\n   ​\n\n三种背包混合背包问题\n问题：如果将P01、P02、P03混合起来。也就是说，有的物品只可以取一次（01背包），有的物品可以取无限次（完全背包），有的物品可以取的次数有一个上限（多重背包）。应该怎么求解呢？\n​    混合背包也没啥，其实就是在原先的基础上多了一个每个物品可用的最大次数的数组，然后当我们每次去进行最内层循环的时候我们的k值进行控制最大值不能够超过我们对应的物品的最大数量就可以了。同时判断的时候分为两种情况一种是01背包和多重背包，另外一种是完全背包，我们的背包数量的数组0就代表了这种物品可以放无限次，也就是因为这这是一种完全背包。\n代码示例如下：\n1public class PackageProblemMixed {\n\n\n\n\n   public static void main(String[] args) {\n\n       //定义三个物品的重量\n       int[] weight = {1, 4, 3, 5};\n\n       //定义三个物品的价值\n       int[] value = {1500, 3000, 2000, 5000};\n\n       //定义三种物品的最大数量 0代表无限次数\n       int[] num = {2, 4,0,5};\n       //定义一共有多少个物品\n       int n = value.length;\n\n       //定义背包所能够承载的最大重量\n       int m = 10;\n\n       int[][] dp = new int[n + 1][m + 1];\n\n\n       //完全背包问题无非就是商品可以重复选择，此时需要在原来的基础上进行多一次的循环，就是对于选择的商品数量进行循环\n       for (int i = 1; i &lt; dp.length; i++) {\n\n           for (int j = 1; j &lt; dp[0].length; j++) {\n\n               if (num[i-1] != 0) {\n\n                   for (int k = 0; k &lt;num[i-1]&amp;&amp;j&gt;k * weight[i - 1]; k++) {\n\n                       dp[i][j] = Math.max(dp[i - 1][j], value[i-1] + dp[i - 1][j - k * weight[i - 1]]);\n\n                   }\n\n               }else {\n\n                   for (int k = 0; k * weight[i-1] &lt; j; k++) {\n\n                       dp[i][j] = Math.max(dp[i - 1][j], value[i - 1] + dp[i - 1][j - k * weight[i - 1]]);\n\n                   }\n\n               }\n\n           }\n\n       }\n\n       for (int i = 0; i &lt; dp.length; i++) {\n\n           System.out.println(Arrays.toString(dp[i]));\n\n       }\n\n\n   }\n   }\n   1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859   ​5. **二维费用的背包问题**   问题：   二维费用的背包问题是指：对于每件物品，具有两种不同的费用；选择这件物品必须同时付出这两种代价；对于每种代价都有一个可付出的最大值（背包容量）。问怎样选择物品可以得到最大的价值。设这两种代价分别为代价1和代价2，第$i$件物品所需的两种代价分别为$a[i]和b[i]$。两种代价可付出的最大值（两种背包容量）分别为V和U。物品的价值为$w[i]$。   ​\t在原先的背包问题中咱们只限制了总的重量不可以超过背包的总重量，二维费用的问题只不过是在原先的基础上加了一层限制而已。   代码示例：   &#96;&#96;&#96;java   public class PackageProblemTwoDimensional {       public static void main(String[] args) {           &#x2F;&#x2F;定义三个背包的重量           int[] weight &#x3D; {1, 4, 3};           &#x2F;&#x2F;第二维的重量限制           int[] weight2 &#x3D; {2, 4, 6};           &#x2F;&#x2F;定义三个背包的价值           int[] value &#x3D; {1500, 3000, 2000};           &#x2F;&#x2F;定义背包所能够承载的最大重量           int m &#x3D; 4;           &#x2F;&#x2F;第二维的重量限制           int m2 &#x3D; 8;           int[][] dp &#x3D; new int[m + 1][m2 + 1];           for (int i &#x3D; 1; i &lt;weight.length; i++) {               for (int j &#x3D; m; j &gt;&#x3D; weight[i - 1]; j--) {                   for (int k &#x3D; m2; k &gt;&#x3D; weight2[i - 1]; k--) {                       dp[j][k] &#x3D; Math.max(dp[j][k], dp[j - weight[i - 1]][k - weight2[i - 1]] + value[i - 1]);                   }               }           }           for (int i &#x3D; 0; i &lt; dp.length; i++) {               System.out.println(Arrays.toString(dp[i]));           }       }   }\n\n\n分组背包问题\n问题：有N件物品和一个容量为V的背包。第$i$件物品的费用是$c[i]$，价值是$w[i]$。这些物品被划分为若干组，每组中的物品互相冲突，最多选一件。求解将哪些物品装入背包可使这些物品的费用总和不超过背包容量，且价值总和最大。\n​    分组背包问题就是01背包+完全背包的高级进阶，因为你需要从各个组中选择出数据，然后组内的数据互斥，不能选两边，但是组可以选两次，对于每组的商品我们有几种选择呢，如果这个组内有n个商品那么一共有n+1种选择，不选择也算是一种选择，所以是n+1种选择。我们此时的最外层循环应该是分组的数量，第二层循环应该是背包的重量，最内层循环应该是每组的商品的重量。\n代码示例如下：\n1234567891011121314151617181920212223242526272829import java.util.Scanner;public class Bag4 {    public static void main(String[] args) {        Scanner sc=new Scanner(System.in);        int n=sc.nextInt();        int m=sc.nextInt();        int[][] f=new int[n+2][m+2];        for (int i = 1; i &lt;=n ; i++) {            int num=sc.nextInt();            for (int j = 0; j &lt;num ; j++) {                int v=sc.nextInt();                int w=sc.nextInt();                for (int k = m; k&gt;=v; k--) {                    f[i][k]=Math.max(f[i][k],f[i-1][k-v]+w);                }/*f[i][k]还没有被遍历到，为0.k《v的时候f[i][k]都为0                如果使用f[i][k]=Math.max(f[i-1][k],f[i-1][k-v]+w)，则会出现取值问题。                例如(f[i-1][k]大于f[i-1][k-v]+w)时 f[i][k]=f[i-1][k]，但在前面num的循环中f[i][k]已经大于f[i-1][k]                此时 f[i][k]应该等于之前的f[i-1][k-v]+w，而不是f[i-1][k]*/            }            for (int k = m; k&gt;=0; k--)//需要遍历到0            {                f[i][k]=Math.max(f[i][k],f[i-1][k]);            }//保证 f[i][k]最大值，应该可以优化，将j的循环放入到k中        }        System.out.println(f[n][m]);    }}\n\n\n\n\n\n\n背包问题求方案数\n简化的问题：这种背包问题的物品间存在某种“依赖”的关系。也就是说，$i$依赖于$j$，表示若选物品$i$，则必须选物品$j$。为了简化起见，我们先设没有某个物品既依赖于别的物品，又被别的物品所依赖；另外，没有某件物品同时依赖多件物品。\n\n\n\n求背包问题的方案\n一般而言，背包问题是要求一个最优值，如果要求输出这个最优值的方案，可以参照一般动态规划问题输出方案的方法：记录下每个状态的最优值是由状态转移方程的哪一项推出来的，换句话说，记录下它是由哪一个策略推出来的。便可根据这条策略找到上一个状态，从上一个状态接着向前推即可。\n​    思路就是加了一个二维数组用来存储方案，我们来借用01背包问题来做个代码示例。\n代码示例如下：\n1public class PackageProblem01 {\n\n\n\n\n   public static void main(String[] args) {\n\n       //定义三个物品的重量\n       int[] weight = {1, 4, 3};\n\n       //定义三个物品的价值\n       int[] value = {1500, 3000, 2000};\n\n       //定义一共有多少个物品\n       int n = value.length;\n\n       //定义背包所能够承载的最大重量\n       int m = 4;\n\n       //定义一个二维数组用来存放放入物品的顺序\n       int[][] path = new int[n + 1][m + 1];\n       int[][] dp = new int[n + 1][m + 1];\n\n       //双层循环，最外层是物品的循环内层是容量的循环\n       for (int i = 1; i &lt; dp.length; i++) {\n\n           for (int j = 1; j &lt; dp[0].length; j++) {\n               if (weight[i - 1] &gt; j) {\n                   dp[i][j] = dp[i - 1][j];\n               } else {\n\n                   if (dp[i - 1][j] &lt; value[i - 1] + dp[i - 1][j - weight[i - 1]]) {\n                       path[i][j] = 1;\n                       dp[i][j] = value[i - 1] + dp[i - 1][j - weight[i - 1]];\n\n                   } else {\n\n                       dp[i][j] = dp[i - 1][j];\n                   }\n\n               }\n\n           }\n\n\n       }\n\n       //最后来遍历一下放入背包的物品 此时需要倒序遍历\n       int i = path.length - 1;\n       int j = path[0].length - 1;\n       while (i &gt; 0 &amp;&amp; j &gt; 0) {\n           if (path[i][j] == 1) {\n               //意味着放入了背包\n               System.out.println(i + &quot;放入背包&quot;);\n               j = j - weight[i - 1];\n           }\n\n           i--;\n\n       }\n\n\n   }\n   }\n\n有依赖的背包问题\n来源牛客网：\n王强今天很开心，公司发给N元的年终奖。王强决定把年终奖用于购物，他把想买的物品分为两类：主件与附件，附件是从属于某个主件的，下表就是一些主件与附件的例子：\n\n\n\n\n\n主件\n附件\n\n\n\n电脑\n打印机，扫描仪\n\n\n书柜\n图书\n\n\n书桌\n台灯，文具\n\n\n工作椅\n无\n\n\n   如果要买归类为附件的物品，必须先买该附件所属的主件。每个主件可以有 0 个、 1 个或 2 个附件。附件不再有从属于自己的附件。王强想买的东西很多，为了不超出预算，他把每件物品规定了一个重要度，分为 5 等：用整数 1 ~ 5 表示，第 5 等最重要。他还从因特网上查到了每件物品的价格（都是 10 元的整数倍）。他希望在不超过 N 元（可以等于 N 元）的前提下，使每件物品的价格与重要度的乘积的总和最大。\n 设第 j 件物品的价格为 v[j] ，重要度为 w[j] ，共选中了 k 件物品，编号依次为 j 1 ， j 2 ，……， j k ，则所求的总和为：\n   v[j 1 ]*w[j 1 ]+v[j 2 ]*w[j 2 ]+ … +v[j k ]*w[j k ] 。（其中 * 为乘号）\n 请你帮助王强设计一个满足要求的购物单。\n输入描述:   1234567输入的第 1 行，为两个正整数，用一个空格隔开：N m（其中 N （ &lt;32000 ）表示总钱数， m （ &lt;60 ）为希望购买物品的个数。）从第 2 行到第 m+1 行，第 j 行给出了编号为 j-1 的物品的基本数据，每行有 3 个非负整数 v p q（其中 v 表示该物品的价格（ v&lt;10000 ）， p 表示该物品的重要度（ 1 ~ 5 ）， q 表示该物品是主件还是附件。如果 q&#x3D;0 ，表示该物品为主件，如果 q&gt;0 ，表示该物品为附件， q 是所属主件的编号）\n\n\n\n\n\n输出描述:   1输出文件只有一个正整数，为不超过总钱数的物品的价格与重要度乘积的总和的最大值（ &lt;200000 ）。\n\n   示例1\n输入   1234561000 5800 2 0400 5 1300 5 1400 3 0500 2 0\n\n输出   12200\n\n   ​    \n   ​    一个“主件”和它的附件集合，实际上是一个物品组，每一个选择某个“主件”或者“主件+附件”的策略，实际上相当于这个物品组中的一个物品，其费用和价值，都是策略中的物品的值的总和。这样的话，对于该简化描述的依赖背包问题的，可以转化为分组背包问题，参考分组背包问题的解决思路，可以解决该问题。\n   代码示例如下：\n   1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import java.util.Scanner;public class PackageProblemRely {    public static void main(String[] args) {        Scanner scanner = new Scanner(System.in);        // 总钱数        int N = scanner.nextInt();        // 购买物品个数        int m = scanner.nextInt();        int[] f = new int[N + 1];        // 分组，goods[i][0]为主件，goods[i][1]为附件1，goods[i][2]为附件2        Good[][] goods1 = new Good[60][4];        for (int i = 1; i &lt;= m; i++) {            int v = scanner.nextInt();            int p = scanner.nextInt();            int q = scanner.nextInt();            Good t = new Good(v, v * p);            if (q == 0) {                goods1[i][0] = t;            } else {                if (goods1[q][1] == null) {                    goods1[q][1] = t;                } else {                    goods1[q][2] = t;                }            }        }        for (int i = 1; i &lt;= m; i++) {            for (int j = N; j &gt;= 0 &amp;&amp; goods1[i][0] != null; j--) {                //以下代码从分组中选择价值最大的。共五种情况：不选主件，选主件，选附件1和主件，选附件2和主件，选附件1和附件2和主件                Good master = goods1[i][0];                int max = f[j];                if (j &gt;= master.v) {                    max=Math.max(max,f[j - master.v] + master.vp);                }                //如果附件1不为null                int vt;                if (goods1[i][1] != null) {                    if (j &gt;= (vt = master.v + goods1[i][1].v) ){                        max = Math.max(max,f[j - vt] + master.vp + goods1[i][1].vp);                    }                }                //如果附件2不为null                if (goods1[i][2] != null) {                    if (j &gt;= (vt = master.v + goods1[i][1].v + goods1[i][2].v)) {                        max = Math.max(max,f[j - vt] + master.vp + goods1[i][1].vp + goods1[i][2].vp);                    }                }                f[j] = max;            }        }        System.out.println(f[N]);    }}class Good {    int v;    int vp;    public Good(int v, int vp) {        this.v = v;        this.vp = vp;    }}","url":"/2020/08/16/背包九讲/","link":"","plink":"http://yoursite.com/2020/08/16/%E8%83%8C%E5%8C%85%E4%B9%9D%E8%AE%B2/"},{"title":"计算机中的二进制","content":"计算机中的二进制&nbsp; &nbsp; &nbsp; &nbsp; 之前总结过关于二进制的一些知识点，最近又看到关于二进制的一些知识点，想重新将其总结成博客。\n1.关于二进制和十进制的转化&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;关于二进制他分为有符号的二进制和无符号的二进制，这两者的区别就是无符号的二进制他的高位（左侧为高位，右侧为低位和十进制的高低位一样）含义就是代表了数字，而有符号的二进制的高位则是代表了符号位，如果是0表示正数，如果是1表示负数。\n\n二进制转为十进制：\n\n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;通过上边的例子可以看出我们是如何通过二进制转为十进制的，转化方式就是从右边第一位开始为0次方，依次递增往左，然前边的系数就是当前位置对应的1或者0。\n\n例如：对于110这个二进制数据如果他是有符号的那么最高位1就代表了他是负数，那么转为十进制数据就是-2（-($12^1+02^0$)）前边符号位不要动，后边的10进行二进制转换，如果是无符号的那么转为十进制就是6（$12^2+12^1+0*2^0$）。\n\n\n十进制转为二进制\n\n&nbsp;&nbsp;&nbsp;&nbsp;十进制转为二进制的主要思路就是用十进制的数据去除以2，然后记录所得到的余数，最后把所得到的余数从左右往左依次排列即可得到对应的二进制。\n\n例如：对于6这个十进制数据，首先用$6/2=3…….0$，然后用得到的商再3去除以2,$3/2=1……1$ ,最后用得到的1再去除以2即$1/2=0……1$ 此时的商是0就不必继续做除法了，然后我们把得到的余数进行从右向左依次排列即110。如果是负数的十进制，也是首先将数字转为二进制然后在最高位（最右边）再去补一位1。\n\n2.关于二进制的原码、补码、反码原码就是最为简单的机器数表示法，用最高位表示符号位，其他位存储该数的二进制的绝对值。如上边提到的110就是一个原码。\n原码的特点：\n表示直观易懂，与真值转换容易。\n源码中的0有两种表示形式，通常的原码的0用+0表示，但是如果在计算中出现了-0则需要硬件将-0变成+0。\n原码用来表示加减运算复杂，利用原码对l两数进行加法运算的时候需要判断两数的符号，使得同号相加异号相减。\n原码的相反数加上原码不等于0。\n\n反码就是正数的反码还是等于原码；负数的反码就是它的原码除符号位外，按位取反。\n\n例如：我们还是以0110为例，如果这是一个正数那么代表十进制的6，他的反码还是0110，如果是-6，那么他的原码应该是1110此时-6的反码是1001。此时我们来看，-6+6=110+1001=1111，此时得到的这个1111的最高位表示-，他也就是-0的相反数，也就是0。但是如果是-6+(-1)=1001+1110=10111这个10111是-8的反码，也就是意味着负数相加还是有问题的。\n\n反码的特点\n在反码中还是用最高位表示符号位，即0正1负。\n在反码中0有两种表现形式，也是+0和-0。\n反码的表示范围与原码的表示范围一样。\n反码解决了一个正数的相反数加这个正数正好等于0的问题，但是面临着另外一个问题，就是两个负数相加存在数据问题。\n\n补码就是正数的补码等于他的原码，负数的补码等于反码+1。\n&nbsp;&nbsp;&nbsp;&nbsp;其实负数的补码等于反码+1只是补码的求法，而不是补码的定义，很多人以为求补码就要先求反码，其实并不是，那些计算机学家并不会心血来潮的把反码+1就定义为补码，只不过补码正好就等于反码+1而已。\n&nbsp;&nbsp;&nbsp;&nbsp;其实补码的思想是非常巧妙的在《码农翻身》一书中这样推导介绍过补码：\n\n&nbsp;&nbsp;&nbsp;&nbsp;在不考虑负数的情况下：如果我们有个4位的二进制数据110这个数据表示的是十进制的6，如果我们把4位全放上1我们可以表示的数是0-15，如果我们想算6-2那么我们可以直接用6+2的补数，此时2的补数就是16-2=14，这样我们可以利用6+14得到这个结果，6+14是个20此时已经发生了溢出即比我们表示的最大数15都已经大了，所以除去溢出的部分我们得到的结果位20-16=4，这样我们得到了最终的结果4。\n&nbsp;&nbsp;&nbsp;&nbsp;即便我们利用二进制来进行计算也会得到同样的效果，即0110+1110=10100这是将最高位的1进行溢出得到0100就是我们十进制4。这种思想有点类似与我们的时钟，如果现在是7点我们想让他回到四点此时我们有两种方案，一种是退回到4点，另外一种是前进9格到达4点。这种方式就是数学中的取模操作。那么在无符号的情况下我们该如何计算补码呢，总不能每次按照位数进行减法运算，于是有一种适合计算机的计算补数的方法出来了，就是二进制所有位数取反然后加1（注：这个运算方式只适合无符号的计算。）\n\n\n&nbsp;&nbsp;&nbsp;&nbsp;但是在计算机中我们一般都是有符号的计算，如果在我们考虑负数的情况下：那么最高位就要表示符号位了，此时我们的四位就是可以表示-7到-0以及0-7，此时多了个-0，我们可以将-0当作-8来处理这样就可以表示的数是-8-7，此时我们求补数的逻辑也不应该是之前的那个逻辑了，计算补码应该是我们的符号位保持不变然后数据进行取反加1，如果此时我们来计算6-2那么在二进制中-2的原码应该是1010然后符号位不变得到1101，然后加1得到1110（其实这对应了我们十进制的-6）此时的计算应该是0110+1110=10100高位溢出得到0100即十进制的4。\n\n通过上边的分析我们可以看出我们此后对于相减的操作我们利用加法器就可以实现减法的操作，可以极大简化电路的设计，在计算机内部，我们就是利用了补码来进行二进制表示的，例如java中的Integer.toBinaryString这个ApI就是返回的补码。\n3.二进制的位移操作以及或且非\n“&gt;&gt;”这个符号是右移操作，右移表示缩小2的N次方\n往右移动即所有的二进制位往右移动两位以后高位补0，例如0000 0110&gt;&gt;2右移两位，得到0000 0001。\n\n“&lt;&lt;”这个符号是左移操作，左移则表示放大2的N次方\n往左移动就是所有的二进制位往左移动两位低位补0，如0000 0110&lt;&lt;2得到0001 1000。\n\n无符号右移( &gt;&gt;&gt; ) \n需要使用其补码进行计算，正数和上边一样操作，负数需要在高位补1。\n\n无符号右移( &lt;&lt;&lt;) \n需要使用其补码进行计算，正数的补码等于自己，负数的补码不和负数一样。低位补0。\n\n位与( &amp; )  \n第一个操作数的的第n位于第二个操作数的第n位如果都是1，那么结果的第n为也为1，否则为0\n\n位或( | )\n 第一个操作数的的第n位于第二个操作数的第n位，只要有一个是1，那么结果的第n为也为1，否则为0\n\n位异或( ^ )\n第一个操作数的的第n位于第二个操作数的第n位相反，那么结果的第n为也为1，否则为0\n\n位非( ~ )\n操作数的第n位为1，那么结果的第n位为0，反之。","url":"/2020/08/16/计算机中的二进制/","link":"","plink":"http://yoursite.com/2020/08/16/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6/"}]

      function getIndexByWord(word, text, caseSensitive) {
        var wordLen = word.length;

        if (wordLen === 0) {
          return [];
        }

        var startPosition = 0,
          position = [],
          index = [];

        if (!caseSensitive) {
          text = text.toLowerCase();
          word = word.toLowerCase();
        }

        while ( (position = text.indexOf(word, startPosition) ) > -1) {
          index.push({
            position: position,
            word: word
          });

          startPosition = position + wordLen;
        }
        return index;
      }

      function highlightKeyword(text, slice) {
        var result = '';
        var prevEnd = slice.start;
        slice.hits.forEach(function (hit) {
          result += text.substring(prevEnd, hit.position);
          var end = hit.position + hit.length;
          result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
          prevEnd = end;
        });
        result += text.substring(prevEnd, slice.end);
        return result;
      }

      function searchFunc(search_id, content_id) {

        var DB = searchData;
        var input = document.getElementById(search_id);
        var resultContent = document.getElementById(content_id);

        var inputEventFunction = function () {
          var searchText = input.value.trim().toLowerCase();

          if(!searchText){
            return;
          }

          var keywords = searchText.split(/[\s\-]+/);
          if (keywords.length > 1) {
            keywords.push(searchText);
          }

          var resultItems = [];

          if (searchText.length > 0) {

            DB.forEach(function (item) {
              var isMatch = false;
              var hitCount = 0;
              var searchTextCount = 0;
              var title = item.title ? item.title.trim() : '';
              var titleInLowerCase = title.toLowerCase();
              var content = item.content ? item.content.trim().replace(/<[^>]+>/g, "") : '';
              var contentInLowerCase = content.toLowerCase();
              var articleUrl = decodeURIComponent(item.url);

              var indexOfTitle = [];
              var indexOfContent = [];

              keywords.forEach(function (keyword) {
                indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
              });


              if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                isMatch = true;
                hitCount = indexOfTitle.length + indexOfContent.length;
              }

              if (isMatch) {

                [indexOfTitle, indexOfContent].forEach(function (index) {
                  index.sort(function (itemLeft, itemRight) {
                    if (itemRight.position !== itemLeft.position) {
                      return itemRight.position - itemLeft.position;
                    } else {
                      return itemLeft.word.length - itemRight.word.length;
                    }
                  });
                });

                function mergeIntoSlice(text, start, end, index) {
                  var item = index[index.length - 1];
                  var position = item.position;
                  var word = item.word;
                  var hits = [];
                  var searchTextCountInSlice = 0;
                  while (position + word.length <= end && index.length != 0) {
                    if (word === searchText) {
                      searchTextCountInSlice++;
                    }
                    hits.push({ position: position, length: word.length });
                    var wordEnd = position + word.length;

                    index.pop();
                    while (index.length != 0) {
                      item = index[index.length - 1];
                      position = item.position;
                      word = item.word;
                      if (wordEnd > position) {
                        index.pop();
                      } else {
                        break;
                      }
                    }
                  }
                  searchTextCount += searchTextCountInSlice;
                  return {
                    hits: hits,
                    start: start,
                    end: end,
                    searchTextCount: searchTextCountInSlice
                  };
                }

                var slicesOfTitle = [];
                if (indexOfTitle.length != 0) {
                  slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                }

                var slicesOfContent = [];
                while (indexOfContent.length != 0) {
                  var item = indexOfContent[indexOfContent.length - 1];
                  var position = item.position;
                  var word = item.word;

                  var start = position - 20;
                  var end = position + 80;
                  if (start < 0) {
                    start = 0;
                  }
                  if (end < position + word.length) {
                    end = position + word.length;
                  }
                  if (end > content.length) {
                    end = content.length;
                  }
                  slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                }

                slicesOfContent.sort(function (sliceLeft, sliceRight) {
                  if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                    return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                  } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                    return sliceRight.hits.length - sliceLeft.hits.length;
                  } else {
                    return sliceLeft.start - sliceRight.start;
                  }
                });

                slicesOfContent = slicesOfContent.slice(0, 2);

                var resultItem =  "<li class='item'><a target='_blank' href='" + articleUrl + "' class='search-result-title'>" + (slicesOfTitle.length? highlightKeyword(title, slicesOfTitle[0]) : title)+ "</a>";

                slicesOfContent.forEach(function (slice) {
                  resultItem += "<a target='_blank' class='search-result-link' href='" + articleUrl + "'>" +
                    "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                    "...</p>" + "</a>";
                });

                resultItem += "</li>";
                resultItems.push({
                  item: resultItem,
                  searchTextCount: searchTextCount,
                  hitCount: hitCount,
                  id: resultItems.length
                });
              }
            })
            Jcount.innerHTML = resultItems.length;
          };

          if (keywords.length === 1 && keywords[0] === "") {
            resultContent.innerHTML = '<div id="no-result"></div>'
          } else if (resultItems.length === 0) {
            resultContent.innerHTML = '<div id="no-result"></div>'
          } else {
            resultItems.sort(function (resultLeft, resultRight) {
              if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                return resultRight.searchTextCount - resultLeft.searchTextCount;
              } else if (resultLeft.hitCount !== resultRight.hitCount) {
                return resultRight.hitCount - resultLeft.hitCount;
              } else {
                return resultRight.id - resultLeft.id;
              }
            });
            var searchResultList = '<ul class=\"search-result-list\">';
            resultItems.forEach(function (result) {
              searchResultList += result.item;
            })
            searchResultList += "</ul>";
            resultContent.innerHTML = searchResultList;
          }
        }

        input.addEventListener('input', inputEventFunction);
        input.addEventListener('keydown', (e)=>{
          if (e.keyCode=='13') {
            inputEventFunction()
          }
        });
      }
      searchFunc('Jinput', 'JresList')
    </script>
  </div>
</article>
        </div>
        
        
      </div>
      <footer id="footer" class="inner">
        © 2020 - TankyZhang -
        <span id="busuanzi_container_site_pv">PV <span id="busuanzi_value_site_pv"></span></span>
        <p>Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> & <a href="https://github.com/thinkerchan/hexo-theme-greyshade" target="_blank" rel="noopener">GreyShade</a></p>
      </footer>
    </div>
  </div>
  
  <script async defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
  
  <script async defer src="https://s5.cnzz.com/z_stat.php?id=1276809529&web_id=1276809529"></script>
  
</body>
</html>